# Fix duplicate assistant messages

## Problem

Assistant replies that use tools currently appear as two different messages in the UI: one message for the tool invocation and a second message for the final text. This happens even though the AI SDK represents the conversation as a single assistant message whose `parts` array contains text/tool/tool-result segments. Because the persistence layer stores each callback as a new row, the UI has no way to stitch the tool call and final text back together, so they render as separate bubbles.

## Root cause

- The server writes assistant data during both `onStepFinish` and `onFinish`. Each callback calls `saveAssistantMessages`, which inserts a new row when the incoming message is missing an `id` (the AI SDK generates an ID, but when it’s undefined we call `nanoid()`). This produces duplicates as soon as two callbacks fire for the same logical assistant turn.
- Tool steps trigger `onStepFinish`, while plain text still fires `onStepFinish` once before `onFinish`. Because we INSERT on each callback rather than UPSERT by the AI‑provided `message.id`, the same logical assistant turn is split into multiple DB rows.
- The persistence code snapshots the entire `response.messages` array but writes each assistant snapshot independently instead of merging the `parts` into a single row keyed by message ID.

## Implementation steps

1. **Normalize assistant messages:**
   - During `onStepFinish`/`onFinish`, pull the last assistant message from `response.messages`.
   - Ensure we always capture the `message.id` generated by the AI SDK. If it is missing, generate one *once* at the beginning of the assistant turn and reuse it for all future updates (store it in a map keyed by job ID).

2. **UPSERT instead of INSERT:**
   - Change the SQLite persistence logic to `INSERT INTO ... ON CONFLICT(id) DO UPDATE SET content = excluded.content, updated_at = CURRENT_TIMESTAMP`.
   - This allows both callbacks to update the same row rather than creating new rows.

3. **Store full `parts` array on every update:**
   - Serialize `message.parts` as-is so a single assistant message row contains intro text, tool call, tool output, and final text.
   - If interim updates arrive (e.g., before the tool result), the row gets overwritten with the latest version, preserving streaming state without duplicates.

4. **Limit callback writes:**
   - Option A: Only persist from `onStepFinish` (since it fires after each step, including the final one) and remove `saveAssistantMessages` from `onFinish`.
   - Option B: Keep both callbacks but wrap writes with a guard so `onFinish` skips persistence when it has the same `message.id` and `updatedAt` as the most recent row.

5. **Verify UI rendering:**
   - After implementing UPSERT, fetch a conversation that used tools and confirm the assistant row’s `parts` contain both the tool invocation and final text so the UI renders them as one message.
